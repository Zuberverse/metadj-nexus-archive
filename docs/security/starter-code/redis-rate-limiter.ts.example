/**
 * Redis Rate Limiter - Starter Code
 *
 * Distributed rate limiting using Upstash Redis.
 * Copy this to /src/lib/ai/redis-rate-limiter.ts when ready to implement.
 *
 * Dependencies:
 *   npm install @upstash/ratelimit @upstash/redis
 *
 * Environment Variables:
 *   UPSTASH_REDIS_REST_URL - Upstash Redis REST URL
 *   UPSTASH_REDIS_REST_TOKEN - Upstash Redis REST token
 *
 * @see /docs/security/REDIS-RATE-LIMITING-PLAN.md
 */

import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import type { NextRequest } from 'next/server';
import { createHash } from 'crypto';

// ============================================================================
// Configuration
// ============================================================================

/** Maximum messages allowed per time window */
export const MAX_MESSAGES_PER_WINDOW = 20;

/** Time window in seconds for rate limiting */
export const RATE_LIMIT_WINDOW_SECONDS = 5 * 60; // 5 minutes

/** Minimum milliseconds between messages (burst prevention) */
export const MIN_MESSAGE_INTERVAL_MS = 500;

/** Session cookie name for client identification */
export const SESSION_COOKIE_NAME = 'metadjai-session';

/** Session cookie max age in seconds */
export const SESSION_COOKIE_MAX_AGE = 7 * 24 * 60 * 60; // 7 days

/** Session cookie path restriction */
export const SESSION_COOKIE_PATH = '/api/metadjai';

// Message limits (unchanged from in-memory implementation)
export const MAX_HISTORY = 12;
export const MAX_CONTENT_LENGTH = 4000;
export const MAX_MESSAGES_PER_REQUEST = 50;

// ============================================================================
// Types
// ============================================================================

export interface ClientIdentifier {
  id: string;
  isFingerprint: boolean;
}

export interface RateLimitResult {
  allowed: boolean;
  remainingMs?: number;
  remaining?: number;
  limit?: number;
}

// ============================================================================
// Redis Initialization
// ============================================================================

/**
 * Initialize Redis client from environment variables
 * Returns null if credentials are not configured
 */
function createRedisClient(): Redis | null {
  const url = process.env.UPSTASH_REDIS_REST_URL;
  const token = process.env.UPSTASH_REDIS_REST_TOKEN;

  if (!url || !token) {
    if (process.env.NODE_ENV === 'production') {
      console.warn(
        '[Rate Limiter] Redis not configured. ' +
        'Set UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN. ' +
        'Falling back to in-memory rate limiting.'
      );
    }
    return null;
  }

  return new Redis({ url, token });
}

/**
 * Create rate limiter with sliding window algorithm
 */
function createRateLimiter(redis: Redis): Ratelimit {
  return new Ratelimit({
    redis,
    // Sliding window: smoother rate limiting than fixed window
    limiter: Ratelimit.slidingWindow(
      MAX_MESSAGES_PER_WINDOW,
      `${RATE_LIMIT_WINDOW_SECONDS} s`
    ),
    // Enable analytics for monitoring
    analytics: true,
    // Namespace to avoid key collisions
    prefix: 'metadjai:ratelimit',
  });
}

// Initialize on module load
const redis = createRedisClient();
const rateLimiter = redis ? createRateLimiter(redis) : null;

// ============================================================================
// Public API
// ============================================================================

/**
 * Check if Redis rate limiting is enabled
 */
export function isRedisEnabled(): boolean {
  return rateLimiter !== null;
}

/**
 * Get unique client identifier from request
 *
 * Priority:
 * 1. Session cookie (most reliable)
 * 2. Browser fingerprint hash (fallback)
 */
export function getClientIdentifier(request: NextRequest): ClientIdentifier {
  // Check for session cookie first
  const sessionId = request.cookies.get(SESSION_COOKIE_NAME)?.value;
  if (sessionId) {
    return { id: sessionId, isFingerprint: false };
  }

  // Generate fingerprint from request headers
  const headers = [
    request.headers.get('user-agent') || '',
    request.headers.get('accept-language') || '',
    request.headers.get('accept-encoding') || '',
    request.headers.get('sec-ch-ua') || '',
    request.headers.get('sec-ch-ua-platform') || '',
    request.headers.get('sec-ch-ua-mobile') || '',
    request.headers.get('accept') || '',
  ];

  const fingerprint = headers.join('|');
  const hash = createHash('sha256')
    .update(fingerprint)
    .digest('hex')
    .slice(0, 32);

  return { id: `fp-${hash}`, isFingerprint: true };
}

/**
 * Check if client is rate limited
 *
 * @param identifier - Client identifier string
 * @param isFingerprint - Whether identifier is fingerprint-based
 * @returns Rate limit result with allowed status and remaining info
 */
export async function checkRateLimit(
  identifier: string,
  isFingerprint: boolean
): Promise<RateLimitResult> {
  if (!rateLimiter) {
    // Allow request if Redis not available
    // Consider logging or using in-memory fallback in production
    return { allowed: true };
  }

  try {
    const result = await rateLimiter.limit(identifier);

    if (!result.success) {
      const remainingMs = Math.max(0, result.reset - Date.now());
      return {
        allowed: false,
        remainingMs,
        remaining: result.remaining,
        limit: result.limit,
      };
    }

    return {
      allowed: true,
      remaining: result.remaining,
      limit: result.limit,
    };
  } catch (error) {
    // Allow request on Redis error to prevent blocking users
    console.error('[Rate Limiter] Redis error:', error);
    return { allowed: true };
  }
}

/**
 * Update rate limit counter (no-op for Upstash)
 *
 * Upstash Ratelimit automatically increments on limit() call.
 * This function exists for API parity with the in-memory version.
 */
export function updateRateLimit(_identifier: string): void {
  // No-op: Upstash handles this automatically
}

/**
 * Check burst rate limit (rapid-fire prevention)
 *
 * Prevents users from sending messages too quickly.
 * Uses separate Redis key with short TTL.
 */
export async function checkBurstLimit(
  identifier: string,
  isFingerprint: boolean
): Promise<RateLimitResult> {
  // Skip for fingerprint-based IDs (collision risk)
  if (isFingerprint) {
    return { allowed: true };
  }

  if (!redis) {
    return { allowed: true };
  }

  const burstKey = `metadjai:burst:${identifier}`;

  try {
    const lastRequest = await redis.get<number>(burstKey);

    if (lastRequest) {
      const elapsed = Date.now() - lastRequest;
      if (elapsed < MIN_MESSAGE_INTERVAL_MS) {
        return {
          allowed: false,
          remainingMs: MIN_MESSAGE_INTERVAL_MS - elapsed,
        };
      }
    }

    // Set burst key with short expiry
    await redis.set(burstKey, Date.now(), {
      px: MIN_MESSAGE_INTERVAL_MS * 2,
    });

    return { allowed: true };
  } catch (error) {
    console.error('[Burst Limiter] Redis error:', error);
    return { allowed: true };
  }
}

/**
 * Generate a new session ID
 */
export function generateSessionId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return `session-${crypto.randomUUID()}`;
  }
  return `session-${Date.now()}-${Math.random().toString(36).slice(2)}`;
}

/**
 * Build rate limit error response
 */
export function buildRateLimitResponse(remainingMs: number): {
  error: string;
  retryAfter: number;
} {
  const retryAfterSeconds = Math.ceil(remainingMs / 1000);
  return {
    error: 'Rate limit exceeded. Please wait before sending another message.',
    retryAfter: retryAfterSeconds,
  };
}

/**
 * Combined rate limit check (convenience function)
 *
 * Checks both burst and window limits in one call.
 */
export async function checkRateLimits(
  request: NextRequest
): Promise<RateLimitResult & { identifier: ClientIdentifier }> {
  const identifier = getClientIdentifier(request);

  // Check burst limit first (faster rejection)
  const burstResult = await checkBurstLimit(identifier.id, identifier.isFingerprint);
  if (!burstResult.allowed) {
    return { ...burstResult, identifier };
  }

  // Check window rate limit
  const windowResult = await checkRateLimit(identifier.id, identifier.isFingerprint);
  return { ...windowResult, identifier };
}
